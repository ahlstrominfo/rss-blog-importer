/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RSSBlogImporter
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key))
        destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n")
    indexEnd--;
  return string.substring(0, indexEnd);
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node, options) {
    return options.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = content.replace(/^\n+|\n+$/g, "");
    content = content.replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node, options) {
    content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
    var prefix = options.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start ? Number(start) + index : index + 1) + ".  ";
    }
    return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code = node.firstChild.textContent;
    var fenceChar = options.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options) {
    return "\n\n" + options.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node, options) {
    return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    if (href)
      href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node, options) {
    return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title)
      title = ' "' + title + '"';
    var replacement;
    var reference;
    switch (options.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference = "[" + id + "]: " + href + title;
    }
    this.references.push(reference);
    return replacement;
  },
  references: [],
  append: function(options) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options) {
    if (!content.trim())
      return "";
    return options.emDelimiter + content + options.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options) {
    if (!content.trim())
      return "";
    return options.strongDelimiter + content + options.strongDelimiter;
  }
};
rules.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content)
      return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter) !== -1)
      delimiter = delimiter + "`";
    return delimiter + extraSpace + content + extraSpace + delimiter;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options) {
  this.options = options;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options.blankReplacement
  };
  this.keepReplacement = options.keepReplacement;
  this.defaultRule = {
    replacement: options.defaultReplacement
  };
  this.array = [];
  for (var key in options.rules)
    this.array.push(options.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter) {
    this._keep.unshift({
      filter,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter) {
    this._remove.unshift({
      filter,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank)
      return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options))
      return rule;
    if (rule = findRule(this._keep, node, this.options))
      return rule;
    if (rule = findRule(this._remove, node, this.options))
      return rule;
    return this.defaultRule;
  },
  forEach: function(fn) {
    for (var i = 0; i < this.array.length; i++)
      fn(this.array[i], i);
  }
};
function findRule(rules2, node, options) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node, options))
      return rule;
  }
  return void 0;
}
function filterValue(rule, node, options) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase())
      return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1)
      return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options))
      return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options) {
  var element = options.element;
  var isBlock2 = options.isBlock;
  var isVoid2 = options.isVoid;
  var isPre = options.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element))
    return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node = remove(node);
        continue;
      }
      node.data = text;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (root.ActiveXObject)
      useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node(node, options) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options) {
  if (node.isBlock || options.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node, options) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options) {
  if (!(this instanceof TurndownService))
    return new TurndownService(options);
  var defaults = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults, options);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "")
      return "";
    var output = process.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++)
        this.use(plugin[i]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter) {
    this.rules.keep(filter);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter) {
    this.rules.remove(filter);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape) {
      return accumulator.replace(escape[0], escape[1]);
    }, string);
  }
};
function process(parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node(node, self.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing)
    content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s1 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var turndown_browser_es_default = TurndownService;

// main.ts
var DEFAULT_SETTINGS = {
  rssUrl: "",
  folderPath: "Blog Posts",
  imageFolder: "Blog Images",
  lastImportedPostDate: 0,
  fetchOnStartup: true,
  appendBacklink: "",
  enableCategoryBacklinks: false
};
var RSSBlogImporter = class extends import_obsidian.Plugin {
  async onload() {
    console.log("=== RSS BLOG IMPORTER PLUGIN STARTING ===");
    console.log("[RSS Importer] Plugin loading...");
    await this.loadSettings();
    console.log("[RSS Importer] Plugin loaded with settings:", {
      rssUrl: this.settings.rssUrl,
      folderPath: this.settings.folderPath,
      imageFolder: this.settings.imageFolder,
      fetchOnStartup: this.settings.fetchOnStartup,
      lastImportedPostDate: new Date(this.settings.lastImportedPostDate).toISOString()
    });
    this.turndownService = new turndown_browser_es_default({
      headingStyle: "atx",
      hr: "---",
      bulletListMarker: "-",
      codeBlockStyle: "fenced",
      fence: "```",
      emDelimiter: "*",
      strongDelimiter: "**",
      linkStyle: "inlined",
      linkReferenceStyle: "full"
    });
    this.addCommand({
      id: "fetch-rss-posts",
      name: "Fetch RSS Posts",
      callback: () => this.fetchRSSPosts()
    });
    this.addSettingTab(new RSSBlogImporterSettingTab(this.app, this));
    if (this.settings.fetchOnStartup && this.settings.rssUrl) {
      console.log("[RSS Importer] Fetch on startup enabled, scheduling fetch in 2 seconds...");
      setTimeout(() => {
        console.log("[RSS Importer] Executing scheduled startup fetch");
        this.fetchRSSPosts();
      }, 2e3);
    } else {
      console.log("[RSS Importer] Fetch on startup disabled or no RSS URL configured");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async fetchRSSPosts() {
    var _a, _b, _c;
    console.log("=== FETCH RSS POSTS CALLED ===");
    console.log("Current time:", new Date().toISOString());
    if (!this.settings.rssUrl) {
      console.log("[RSS Importer] No RSS URL configured");
      new import_obsidian.Notice("Please configure RSS URL in settings");
      return;
    }
    try {
      console.log("[RSS Importer] Starting RSS fetch process");
      console.log("[RSS Importer] Settings:", {
        rssUrl: this.settings.rssUrl,
        folderPath: this.settings.folderPath,
        lastImportedPostDate: new Date(this.settings.lastImportedPostDate).toISOString(),
        lastImportedPostDateMs: this.settings.lastImportedPostDate
      });
      new import_obsidian.Notice("Fetching RSS posts...");
      const cacheBustUrl = this.settings.rssUrl + (this.settings.rssUrl.includes("?") ? "&" : "?") + "_t=" + Date.now();
      console.log("[RSS Importer] Fetching URL:", cacheBustUrl);
      const response = await (0, import_obsidian.requestUrl)({
        url: cacheBustUrl,
        headers: {
          "Cache-Control": "no-cache",
          "Pragma": "no-cache"
        }
      });
      console.log("[RSS Importer] Response status:", response.status);
      console.log("[RSS Importer] Response size:", response.text.length, "characters");
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(response.text, "application/xml");
      const parseError = xmlDoc.querySelector("parsererror");
      if (parseError) {
        console.error("[RSS Importer] XML parsing error:", parseError.textContent);
        throw new Error("Failed to parse RSS feed XML");
      }
      const feedTitle = ((_a = xmlDoc.querySelector("title")) == null ? void 0 : _a.textContent) || "Unknown Feed";
      const items = Array.from(xmlDoc.querySelectorAll("item, entry"));
      console.log("[RSS Importer] Feed title:", feedTitle);
      console.log("[RSS Importer] Total items found:", items.length);
      let newPostsCount = 0;
      let skippedPostsCount = 0;
      let latestImportedDate = this.settings.lastImportedPostDate;
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const title = ((_b = item.querySelector("title")) == null ? void 0 : _b.textContent) || `Untitled ${i + 1}`;
        const pubDateText = (_c = item.querySelector("pubDate, published, updated")) == null ? void 0 : _c.textContent;
        const pubDate = pubDateText ? new Date(pubDateText) : new Date();
        console.log(`[RSS Importer] Processing item ${i + 1}/${items.length}:`, {
          title,
          pubDateText,
          pubDate: pubDate.toISOString(),
          pubDateMs: pubDate.getTime(),
          lastImportedPostDateMs: this.settings.lastImportedPostDate,
          isNew: pubDate.getTime() > this.settings.lastImportedPostDate
        });
        if (pubDate.getTime() > this.settings.lastImportedPostDate) {
          console.log(`[RSS Importer] Creating new post: ${title}`);
          try {
            await this.createBlogPost(item, feedTitle);
            newPostsCount++;
            if (pubDate.getTime() > latestImportedDate) {
              latestImportedDate = pubDate.getTime();
            }
            console.log(`[RSS Importer] Successfully created post: ${title}`);
          } catch (error) {
            console.error(`[RSS Importer] Failed to create post "${title}":`, error);
          }
        } else {
          skippedPostsCount++;
          console.log(`[RSS Importer] Skipping older post: ${title} (${pubDate.toISOString()})`);
        }
      }
      if (latestImportedDate > this.settings.lastImportedPostDate) {
        console.log("[RSS Importer] Updating lastImportedPostDate:", {
          old: new Date(this.settings.lastImportedPostDate).toISOString(),
          new: new Date(latestImportedDate).toISOString()
        });
        this.settings.lastImportedPostDate = latestImportedDate;
        await this.saveSettings();
      } else {
        console.log("[RSS Importer] No new posts imported, keeping existing lastImportedPostDate");
      }
      console.log("[RSS Importer] Import summary:", {
        totalItems: items.length,
        newPosts: newPostsCount,
        skippedPosts: skippedPostsCount
      });
      new import_obsidian.Notice(`Imported ${newPostsCount} new blog posts (${skippedPostsCount} skipped)`);
    } catch (error) {
      console.error("[RSS Importer] Error fetching RSS:", error);
      console.error("[RSS Importer] Error details:", {
        message: error.message,
        stack: error.stack,
        url: this.settings.rssUrl
      });
      new import_obsidian.Notice(`Failed to fetch RSS posts: ${error.message}`);
    }
  }
  async createBlogPost(item, feedTitle) {
    var _a, _b, _c, _d;
    const title = this.sanitizeFileName(((_a = item.querySelector("title")) == null ? void 0 : _a.textContent) || "Untitled");
    const pubDateText = (_b = item.querySelector("pubDate, published, updated")) == null ? void 0 : _b.textContent;
    const pubDate = pubDateText ? new Date(pubDateText) : new Date();
    const dateStr = pubDate.toISOString().split("T")[0];
    const fileName = `${dateStr} - ${title}.md`;
    const filePath = (0, import_obsidian.normalizePath)(`${this.settings.folderPath}/${fileName}`);
    console.log(`[RSS Importer] Creating blog post:`, {
      originalTitle: (_c = item.querySelector("title")) == null ? void 0 : _c.textContent,
      sanitizedTitle: title,
      pubDateText,
      pubDate: pubDate.toISOString(),
      fileName,
      filePath
    });
    await this.app.vault.adapter.mkdir(this.settings.folderPath);
    await this.app.vault.adapter.mkdir(this.settings.imageFolder);
    const contentSelectors = ["content\\:encoded", "content", "description", "summary"];
    let htmlContent = "";
    let usedSelector = "";
    for (const selector of contentSelectors) {
      const element = item.querySelector(selector);
      if (element == null ? void 0 : element.textContent) {
        htmlContent = element.textContent;
        usedSelector = selector;
        break;
      }
    }
    console.log(`[RSS Importer] Content extraction:`, {
      usedSelector,
      contentLength: htmlContent.length,
      hasContent: htmlContent.length > 0
    });
    const imageUrls = this.extractImageUrls(htmlContent, item);
    console.log(`[RSS Importer] Found ${imageUrls.length} images:`, imageUrls);
    const imageMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < imageUrls.length; i++) {
      const imageUrl = imageUrls[i];
      console.log(`[RSS Importer] Processing image ${i + 1}/${imageUrls.length}: ${imageUrl}`);
      try {
        const localImagePath = await this.downloadImage(imageUrl, title);
        if (localImagePath) {
          imageMap.set(imageUrl, localImagePath);
          console.log(`[RSS Importer] Successfully downloaded image: ${imageUrl} -> ${localImagePath}`);
        } else {
          console.log(`[RSS Importer] Failed to download image: ${imageUrl}`);
        }
      } catch (error) {
        console.error(`[RSS Importer] Error downloading image ${imageUrl}:`, error);
      }
    }
    console.log(`[RSS Importer] Image download summary: ${imageMap.size}/${imageUrls.length} successful`);
    for (const [originalUrl, localPath] of imageMap) {
      const regex = new RegExp(originalUrl.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
      const matches = htmlContent.match(regex);
      if (matches) {
        console.log(`[RSS Importer] Replacing ${matches.length} occurrences of ${originalUrl} with ${localPath}`);
        htmlContent = htmlContent.replace(regex, localPath);
      }
    }
    let content = this.turndownService.turndown(htmlContent);
    console.log(`[RSS Importer] Markdown conversion: ${htmlContent.length} chars HTML -> ${content.length} chars Markdown`);
    const categories = this.extractCategories(item);
    console.log(`[RSS Importer] Extracted categories:`, categories);
    content = this.appendBacklinkToContent(content, categories);
    const sourceUrl = ((_d = item.querySelector("link, guid")) == null ? void 0 : _d.textContent) || "";
    console.log(`[RSS Importer] Source URL: ${sourceUrl}`);
    const frontmatter = `---
title: "${title}"
date: ${pubDate.toISOString()}
source: ${sourceUrl}
feed: "${feedTitle || ""}"
imported: ${new Date().toISOString()}
---

`;
    const fullContent = frontmatter + content;
    console.log(`[RSS Importer] Final content length: ${fullContent.length} characters`);
    try {
      await this.app.vault.create(filePath, fullContent);
      console.log(`[RSS Importer] Successfully created file: ${filePath}`);
    } catch (error) {
      if (error.message.includes("already exists")) {
        console.log(`[RSS Importer] Post already exists: ${fileName}`);
        throw new Error(`Post already exists: ${fileName}`);
      } else {
        console.error(`[RSS Importer] Failed to create file ${filePath}:`, error);
        throw error;
      }
    }
  }
  extractImageUrls(content, item) {
    const urls = /* @__PURE__ */ new Set();
    const imgRegex = /<img[^>]+src="([^"]+)"/gi;
    let match;
    while ((match = imgRegex.exec(content)) !== null) {
      urls.add(match[1]);
    }
    const mediaElements = item.querySelectorAll("media\\:content");
    for (let i = 0; i < mediaElements.length; i++) {
      const media = mediaElements[i];
      const url = media.getAttribute("url");
      const medium = media.getAttribute("medium");
      if (url && medium === "image") {
        urls.add(url);
      }
    }
    return Array.from(urls);
  }
  async downloadImage(imageUrl, postTitle) {
    try {
      console.log(`[RSS Importer] Downloading image: ${imageUrl}`);
      const response = await (0, import_obsidian.requestUrl)({ url: imageUrl });
      console.log(`[RSS Importer] Image response status: ${response.status}, size: ${response.arrayBuffer.byteLength} bytes`);
      const urlParts = imageUrl.split("/");
      const fileName = urlParts[urlParts.length - 1] || "image";
      const extension = fileName.split(".").pop() || "jpg";
      const sanitizedTitle = this.sanitizeFileName(postTitle);
      const imageName = `${sanitizedTitle}-${Date.now()}.${extension}`;
      const imagePath = (0, import_obsidian.normalizePath)(`${this.settings.imageFolder}/${imageName}`);
      console.log(`[RSS Importer] Saving image as: ${imagePath}`);
      await this.app.vault.createBinary(imagePath, response.arrayBuffer);
      const result = `![[${imageName}]]`;
      console.log(`[RSS Importer] Image download successful: ${imageUrl} -> ${result}`);
      return result;
    } catch (error) {
      console.error(`[RSS Importer] Failed to download image ${imageUrl}:`, error);
      return null;
    }
  }
  sanitizeFileName(name) {
    return name.replace(/[<>:"/\\|?*]/g, "-").replace(/\s+/g, " ").trim();
  }
  extractCategories(item) {
    var _a;
    const categories = [];
    const categoryElements = item.querySelectorAll("category");
    for (let i = 0; i < categoryElements.length; i++) {
      const cat = categoryElements[i];
      const text = (_a = cat.textContent) == null ? void 0 : _a.trim();
      if (text)
        categories.push(text);
    }
    return [...new Set(categories)].map((cat) => cat.trim()).filter((cat) => cat.length > 0);
  }
  appendBacklinkToContent(content, categories = []) {
    let result = content;
    if (this.settings.enableCategoryBacklinks && categories.length > 0) {
      const categoryBacklinks = categories.map((category) => `[[${category}]]`).join(" ");
      result += "\n\n" + categoryBacklinks;
    }
    if (this.settings.appendBacklink.trim()) {
      const backlink = this.settings.appendBacklink.trim();
      const formattedBacklink = backlink.startsWith("[[") && backlink.endsWith("]]") ? backlink : `[[${backlink}]]`;
      result += "\n\n" + formattedBacklink;
    }
    return result;
  }
};
var RSSBlogImporterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("RSS Feed URL").setDesc("The URL of your blog's RSS feed").addText((text) => text.setPlaceholder("https://example.com/rss").setValue(this.plugin.settings.rssUrl).onChange(async (value) => {
      this.plugin.settings.rssUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Blog Posts Folder").setDesc("Folder where blog posts will be saved").addText((text) => text.setPlaceholder("Blog Posts").setValue(this.plugin.settings.folderPath).onChange(async (value) => {
      this.plugin.settings.folderPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Images Folder").setDesc("Folder where downloaded images will be saved").addText((text) => text.setPlaceholder("Blog Images").setValue(this.plugin.settings.imageFolder).onChange(async (value) => {
      this.plugin.settings.imageFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Fetch on Startup").setDesc("Automatically fetch new posts when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.fetchOnStartup).onChange(async (value) => {
      this.plugin.settings.fetchOnStartup = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Category Backlinks").setDesc("Automatically add RSS feed categories as backlinks at the end of posts").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableCategoryBacklinks).onChange(async (value) => {
      this.plugin.settings.enableCategoryBacklinks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Append Backlink").setDesc('Backlink to append at the end of each imported post (e.g., "blog posts")').addText((text) => text.setPlaceholder("blog posts").setValue(this.plugin.settings.appendBacklink).onChange(async (value) => {
      this.plugin.settings.appendBacklink = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Manual Fetch").setDesc("Manually fetch new posts from RSS feed").addButton((button) => button.setButtonText("Fetch Now").setCta().onClick(() => this.plugin.fetchRSSPosts()));
    new import_obsidian.Setting(containerEl).setName("Reset Import Cache").setDesc("Reset the last imported post date to re-import all posts from RSS feed").addButton((button) => button.setButtonText("Reset Cache").setWarning().onClick(async () => {
      this.plugin.settings.lastImportedPostDate = 0;
      await this.plugin.saveSettings();
      new import_obsidian.Notice("Import cache reset. Next fetch will import all posts.");
    }));
  }
};
